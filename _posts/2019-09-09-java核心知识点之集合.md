---

layout:     post
title:      java核心知识点之集合
subtitle:   PPT文档
date:       2019-09-09
author:     skaleto
catalog: true
tags:
    - java

---

[TOC]



# JAVA核心知识点——集合

集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。

1.  Collection：Collection 是集合 List、Set、Queue 的最基本的接口。
2.  Iterator：迭代器，可以通过迭代器遍历集合中的数据
3.  Map：是映射表的基础接口

![1568027501057](C:\Users\iflyrec\AppData\Roaming\Typora\typora-user-images\1568027501057.png)



## Collection

### List

#### ArrayList

ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。

当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。

![1568080676708](C:\Users\iflyrec\AppData\Roaming\Typora\typora-user-images\1568080676708.png)

在ArrayList中，增加元素的时候，数组容量不够时，需要进行扩容

```java
/**
 * 非空情况下，默认的初始数组大小
 */
private static final int DEFAULT_CAPACITY = 10;

public boolean add(E e) {
    //在增加一个元素前，需要先检查一下数组长度够不够再放一个元素
    ensureCapacityInternal(size + 1);
    elementData[size++] = e;
    return true;
}

private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    //当所需的大小大于当前数组的真实大小时，需要扩容
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    //扩容的办法是先尝试将容量调整为当前数组真实大小的1.5倍（右移1位÷2）
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    //调整后的容量和所需的大小以及最大限制大小比较，得出最终容量
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```



#### Vector

Vector与ArrayList非常类似，内部也是数组实现，不同的是它支持线程的同步，即某一时刻只有一
个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，
访问它比访问 ArrayList 慢。

![1568084021855](C:\Users\iflyrec\AppData\Roaming\Typora\typora-user-images\1568084021855.png)

```java
//与ArrayList不同的地方在于，add方法加了锁，使得Vector线程安全
public synchronized void addElement(E obj) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = obj;
}

private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    //扩容的策略也与ArrayList不一样，优先扩容capacityIncrement大小，capacityIncrement未指定时扩容为2倍
    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```



#### LinkedList

LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较
慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆
栈、队列和双向队列使用。

![1568084724511](C:\Users\iflyrec\AppData\Roaming\Typora\typora-user-images\1568084724511.png)

LinkedList的基本数据结构是Node

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

LinkedList的插入删除操作比较简单，我们主要看它的查询操作

```java
Node<E> node(int index) {
    //这里可以看到遍历的逻辑用了二分法，只需遍历index所在的半边
    if (index < (size >> 1)) {
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}
```

另外，从类图中我们看到，LinkedList实现了deque接口，所以我们可以用LinkedList来构造一个队列。

*题外话：如何反转一个链表？*

```java
假设有一个链表，其中的元素为A、B，结构为null->A->B->C->null，反转后为null->C->B->A->null

方式1：循环
以A为例，反转后，A的prev变为B，A的next变为null，以此类推，即每一个元素的prev变为其原本的next，而next变为原本的prev，但是不能直接转，我们需要几个临时节点来存放这些信息。
从逻辑角度来看，我们要做的就是令A.next=A.prev,A.prev=A.next，但是第一步之后A.next已经发生变化，所以需要一个节点来存放A.next
代码如下：
Node cur=head;
Node next=null;
Node prev=null;
while(cur!=null){
	next=cur.next;
	cur.next=prev;
	prev=cur;
	cur=next;
}

方式2：递归
不断将子链表进行递归，直到子链表为最后一个节点；把当前递归的头指向null，当前递归的头的下一个节点指向当前头
public static Node reverseList(Node head){
    if (head == null || head.next == null) {
        return head;
    }
    //递归
    Node newList = reverseList(head.next);

    head.next.next = head;
    head.next = null;
    return newList;
}
```



### Set

#### HashSet

![1568106483722](C:\Users\iflyrec\AppData\Roaming\Typora\typora-user-images\1568106483722.png)

HashSet通过一个HashMap来存放数据，放入的数据作为map的key存放，因为map的key是唯一的，因此HashSet可以做到内部存放的元素为唯一

```java
// Dummy value to associate with an Object in the backing Map
private static final Object PRESENT = new Object();

public boolean add(E e) {
    //将数据作为key存入map中，值为一个空的Object
    return map.put(e, PRESENT)==null;
}
```



#### TreeSet

![1568107837747](C:\Users\iflyrec\AppData\Roaming\Typora\typora-user-images\1568107837747.png)

1.  TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增
加一个对象都会进行排序，将对象插入的二叉树指定的位置。
2.  Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自
己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使
用。
3.  在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序
4.  比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整
数、零或正整数。



#### LinkedHashSet



### Queue





## Map

### HashMap

哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不
同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的
hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较
equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是
同一个元素。
哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相
同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情
况；图 2 表示 hashCode 值相同，但 equals 不相同的情况

![1568107933771](C:\Users\iflyrec\AppData\Roaming\Typora\typora-user-images\1568107933771.png)

HashMap是一个非常经典的数据结构，我们先来看jdk1.8中它的内部结构。首先有一个每个元素都是链表的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。

![1568109404664](C:\Users\iflyrec\AppData\Roaming\Typora\typora-user-images\1568109404664.png)

构造方法如下：

```java
//默认容量为16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
//最大容量为2的30次方
static final int MAXIMUM_CAPACITY = 1 << 30;
//默认负载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;
/**
 * The table, initialized on first use, and resized as
 * necessary. When allocated, length is always a power of two.
 * (We also tolerate length zero in some operations to allow
 * bootstrapping mechanics that are currently not needed.)
 * HashMap内部用来存放数据的结构，是一个Node数组
 */
transient Node<K,V>[] table;

public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
    	//tableSizeFor将传入的容量大小参数转换为大于等于它的最小2次幂
        this.threshold = tableSizeFor(initialCapacity);
}

public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
}

public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}

public HashMap(Map<? extends K, ? extends V> m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
}

/**
 * Returns a power of two size for the given target capacity.
 */
static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

上面为什么要把容量的阈值设置为大于值的最小2次幂呢？带着这个问题我们往下看。

##### HashMap放入元素

放入元素的操作可以参考下图

![](https://images2015.cnblogs.com/blog/249993/201707/249993-20170725160254943-1515467235.png)

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            //为空的或大小为0的时候需要去做resize()扩充数组的长度
            n = (tab = resize()).length;
    	/**
    	 * 这个地方使用(n-1)&hash计算出了需要插入的数组位置的索引
    	 * n为数组的容量，是2的次方，这个地方可以解释我们上面为什么要设置n为2的次方了，见下方
    	 */
        if ((p = tab[i = (n - 1) & hash]) == null)
            //索引未被使用的时候，即当前桶中没有东西的时候，直接在当前索引插入一个新的节点
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            //索引位置处的节点hash值与当前需要放入的hash值相同，并且key也相等，则覆盖替换这个节点
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            //如果key不相同，且索引位置处的节点是红黑树节点
            else if (p instanceof TreeNode)
                //则将当前节点放入红黑树
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                //以上都不满足，则当前是个链表结构，则将当前节点插入链表末尾
                for (int binCount = 0; ; ++binCount) {
                    //如果一直遍历到最后都没有找到相同的key，则向后插入
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        //插入完成后假如数量达到了阈值，则将这个链表结构转化为红黑树
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    //如果key值相等，则跳出循环，因为已经找到了相同的key
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            //上面的操作找到了一个已经存在的相同key的节点
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    //替换value
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
    	//添加完节点后，需要检查大小，超过阈值就需要扩容
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
}
```

##### 为什么要设置容量为2的次方？

在计算存放数组的索引时，使用(n-1)&hash，那么n为2的次方时，n-1所有位全为1，而不是2的次方时，某几位一定存在0。

以下图为例，左边为n=16，右边为n=15，假设他们都和8，9这两个hash值做比较，那么可以知道，n=16的情况下，最终结果和原本的hash值相等，而n=15的情况下，总存在某几位始终为0，这导致这几位为1的索引永远不会用到。比如下图的低1位，始终为0，那么0001,0011,0101等等这些索引都不会被用到，这种情况下增加了碰撞的几率，对应的效率也会下降。

![](https://img2018.cnblogs.com/blog/1320709/201905/1320709-20190519105721190-504233783.png)

##### 计算hash的方法是什么样的过程？

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

从代码字面意思来看是将对象的hashcode无符号右移16位，高位用0补齐，之后再与原本的hashcode进行按位异或操作，为什么要这么计算呢？

上面我们知道，在数组长度比较小的情况下，其实最终的索引值仅仅取决于hash值的低几位，例如下图原本比较大的hash值，假如直接和table.length-1做与运算，它的高位就完全没有存在的意义；

但是假如将hash值右移16位，使高16位可以和原本的低16位做异或，得到的值从某种程度上来说保留了高16位的某些特征，这样再去做索引的计算，一定程度上来说可以减少hash碰撞

![](https://img-blog.csdn.net/20180721235229659?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3YxMjM0MTE3Mzk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



##### 扩容是什么样的操作？

```java
final Node<K,V>[] resize() {
        Node<K,V>[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap > 0) {
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            //oldCap<<1表示扩大一倍，如果当前长度扩大一倍后小于最大容量
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                //那就把当前的阈值也调整扩大一倍咯
                newThr = oldThr << 1;
        }
    	//如果扩容前容量为0，并且阈值大于0 
        else if (oldThr > 0)
            //那么就把容量定义为阈值
            newCap = oldThr;
    	//如果扩容前容量为0，并且阈值也为0
        else {
            //将容量定义为默认容量，阈值定义为容量*负载因子
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
    	//如果扩容后阈值为0，则将阈值设置为扩容后容量*负载因子
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
    	
    	//新的容量和阈值计算完成后，创建一个新的Node数组用来存放数据，那么旧的数据需要重新安排位置
        @SuppressWarnings({"rawtypes","unchecked"})
            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
    	
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    //将i位置的node拿出来，原本的数组位置置为空，使gc可以将该段空间回收
                    oldTab[j] = null;
                    if (e.next == null)
                        //node后面没有链表跟着的情况下，计算新的索引位置并放入即可
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        //node后面跟着的是个红黑树，需要重新构造这个树
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else {
                        //遍历链表中的每个节点，通过节点的hash值与oldCap按位与的结果来判断是否需要改变位置，如果不需要改变位置，则插在新链表中的当前位置链表后方；如果需要改变位置，则插在新链表当前位置+oldCap位置处的链表后方，见下方详解
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
}
```

##### 为什么要用hash值与oldCap按位与来计算最终的位置？

我们假设oldCap为16=0x10000，oldCap-1=0x01111，那么扩容后为32=0x100000，新容量-1=0x011111。以hash值为0x011010和0x001010的两个对象为例：

0x011010 & 0x001111=0x001010

0x001010 & 0x001111=0x001010

两个hash值在oldCap为16的情况下运算得到的索引相同，而容量为32后：

0x011010 & 0x011111=0x011010

0x001010 & 0x011111=0x001010

两个hash值运算后不一致，说明需要放到不同的索引位置，但是这个地方我们可以看到，两次计算完得到的结果差异仅在低5位处，这就意味着，我们只需要将hash值与0x010000做与运算即可得到我们的结果，并且通过结果的0或1来判断是否需要更改链表索引的位置。并且我们知道，当需要更改位置时，其实新的位置与当前位置的差就是oldCap的大小。

##### HashMap中的红黑树结构是什么样的？

红黑树是一种自平衡二叉树，它具有非常高的查询、插入和删除性能。当HashMap中有数据插入或删除时，都有可能触发红黑树的重构，以维持树结构的相对平衡，提高树的搜索效率。关于红黑树的相关介绍，放在其他专题中，这里就不多赘述了。



### ConcurrentHashMap

![1568208018277](C:\Users\iflyrec\AppData\Roaming\Typora\typora-user-images\1568208018277.png)





### HashTable

![1568207891494](C:\Users\iflyrec\AppData\Roaming\Typora\typora-user-images\1568207891494.png)





### TreeMap

![1568207915363](C:\Users\iflyrec\AppData\Roaming\Typora\typora-user-images\1568207915363.png)