---

layout:     post
title:      NIO之Netty
subtitle:   NIO之Netty
date:       2019-10-09
author:     skaleto
catalog: true
tags:
    - nio,netty

---

# 

[TOC]

https://www.cnblogs.com/crazymakercircle/p/10225159.html

https://www.cnblogs.com/crazymakercircle/p/10225159.html



## IO多路复用中Select的底层原理

*前提：每个socket中可以看做拥有一个等待队列，用来存放所有监听它的工作进程

### select

1. 将进程加入到它监听的所有socket的等待队列中，将进程从CPU工作队列中移除，进入阻塞状态
2. 当有一个socket有数据返回时，中断程序把进程从所有的socket等待队列中移除，并把进程重新加入CPU工作队列，进入就绪状态
3. 进程遍历所有socket的状态，知道哪些socket可以读取数据，然后去读取数据
4. 操作完成后，再重复第一步

特点：

- 底层限制了一个select最多监控1024个socket
- 因为需要重复执行所有socket等待队列的加入移除操作，比较耗性能

### poll

与select的原理差不多，但去除了1024个socket的限制

### epoll

进程调用epoll监控多个socket时，会在底层创建一个eventpoll对象，包含了一个就绪队列

1. 进程调用epoll后，epoll将这个进程加入eventpoll对象的等待队列中
2. 将eventpoll对象加入所有socket的等待队列，并使进程阻塞
3. 当有一个socket有数据返回时，中断程序将该socket加入到eventpoll对象的就绪队列中，并把eventpoll中等待的进程唤醒
4. 进程唤醒后直接从就绪队列中获取socket读取数据
5. 操作完成后，再重复第一步，但不需要执行第二步，因为eventpoll对象始终在所有监听的socket中

特点：

- 每个socket的等待队列不会发生频繁的加入移除操作，只会被加入一次eventpoll对象



## Reactor模型

```
反应器模式(Reactor)和观察者模式的联系和区别：
都是当一个主体发生变化时，所有依属体都得到通知
观察者模式与单个时间源关联，而反应器模式与多个事件源关联
```

https://www.cnblogs.com/crazymakercircle/p/9904544.html

实际上的Reactor模式，是基于Java NIO的，在他的基础上，抽象出来两个组件——Reactor和Handler两个组件：

（1）Reactor：负责响应IO事件，当检测到一个新的事件，将其发送给相应的Handler去处理；新的事件包含连接建立就绪、读就绪、写就绪等。

（2）Handler:将自身（handler）与事件绑定，负责事件的处理，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。



### 单线程的Reactor模型

![wpsC334.tmp](https://img2018.cnblogs.com/blog/1485398/201810/1485398-20181022232217633-124484857.jpg)

![wpsC345.tmp](https://img2018.cnblogs.com/blog/1485398/201810/1485398-20181022232218623-1679192697.jpg)

### 多线程的Reactor模型

单线程模式Reactor的缺点：

1、 当其中某个 handler 阻塞时， 会导致其他所有的 client 的 handler 都得不到执行， 并且更严重的是， handler 的阻塞也会导致整个服务不能接收新的 client 请求(因为 acceptor 也被阻塞了)。 因为有这么多的缺陷， 因此单线程Reactor 模型用的比较少。这种单线程模型不能充分利用多核资源，所以实际使用的不多。

2、因此，单线程模型仅仅适用于handler 中业务处理组件能快速完成的场景。



在线程Reactor模式基础上，做如下改进：

（1）将Handler处理器的执行放入线程池，多线程进行业务处理。

（2）而对于Reactor而言，可以仍为单个线程。如果服务器为多核的CPU，为充分利用系统资源，可以将Reactor拆分为两个线程。

![image](https://img2018.cnblogs.com/blog/1485398/201810/1485398-20181022232219420-1734756772.png)

![wpsC376.tmp](https://img2018.cnblogs.com/blog/1485398/201810/1485398-20181022232220631-1867817712.jpg)



![img](https://images0.cnblogs.com/blog2015/434101/201503/112151380898648.jpg)

mainReactor负责监听连接，accept连接给subReactor处理，为什么要单独分一个Reactor来处理监听呢？因为像TCP这样需要经过3次握手才能建立连接，这个建立连接的过程也是要耗时间和资源的，单独分一个Reactor来处理，可以提高性能。



#### Reactor的优缺点

##### 优点

1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；

2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；

3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；

4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；

##### 缺点

1）相比传统的简单模型，Reactor增加了一定的复杂性，因而有一定的门槛，并且不易于调试。

2）Reactor模式需要底层的Synchronous Event Demultiplexer支持，比如Java中的Selector支持，操作系统的select系统调用支持，如果要自己实现Synchronous Event Demultiplexer可能不会有那么高效。

3） Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，会影响这个Reactor中其他Channel的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的Thread-Per-Connection或许是一个更好的选择，或则此时使用改进版的Reactor模式如Proactor模式。



## Netty

### 简介和优点

Netty提供异步的、事件驱动的网络应用程序框架和工具，相比JDK原生NIO，Netty提供了相对十分简单易用的API，非常适合网络编程。Netty是完全基于NIO实现的，所以Netty是异步的。

作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。

Netty的优点可以总结如下

1、API使用简单，开发门槛低；

2、功能强大，预置了多种编解码功能，支持多种主流协议；

3、定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展；

4、性能高，通过与其他业界主流的NIO框架对比，Netty的综合性能最优；

5、成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；

6、社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会加入；



Netty中的Channel系列类型，对应于经典Reactor模型中的client， 封装了用户的通讯连接。

Netty中的EventLoop系列类型，对应于经典Reactor模型中的Reactor，完成Channel的注册、轮询、分发。

Netty中的Handler系列类型，对应于经典Reactor模型中的Handler，不过Netty中的Handler设计得更加的高级和巧妙，使用了Pipeline模式。

![wps562E.tmp](https://img2018.cnblogs.com/blog/1485398/201810/1485398-20181025005656468-925698953.png)





#### NioEventLoop

##### 主要结构

NioEventLoop对应于reactor模式下的Reactor组件，在reactor模式下，我们首先将channel注册到selector上，并attach一个对象，用来处理连接事件，那么在netty中是如何的呢？

下图是NioEventLoop的继承关系和部分代码

![wps565F.tmp](https://img2018.cnblogs.com/blog/1485398/201810/1485398-20181025005657829-91055201.png)

```java
public final class NioEventLoop extends SingleThreadEventLoop {
    //继承了netty自己实现的一个线程池
    ...
    /**
     * The NIO {@link Selector}.
     * 这里有两个selector成员变量，与我们自己实现的Reactor类似
     */
    private Selector selector;
    private Selector unwrappedSelector;
    private SelectedSelectionKeySet selectedKeys;
    ...
}
```

##### Reactor三部曲之注册

Channel向EventLoop注册的过程，是在启动时进行的。注册的入口代码，在启动类AbstractBootstrap.initAndRegister 方法中。

注册入口代码如下：

```java
    final ChannelFuture initAndRegister() {
        Channel channel = null;
        try {
            //TODO 此处反射调用了channel的无参构造方法
            channel = channelFactory.newChannel();
            //不同channel有不同的初始化方法
            init(channel);
        } catch (Throwable t) {
            ...
        }

        ChannelFuture regFuture = config().group().register(channel);
        if (regFuture.cause() != null) {
            if (channel.isRegistered()) {
                channel.close();
            } else {
                channel.unsafe().closeForcibly();
            }
        }

        return regFuture;
    }
```

![wps56A1.tmp](https://img2018.cnblogs.com/blog/1485398/201810/1485398-20181025005659771-650248316.png)



注册阶段的主要代码在AbstractChannel中

```java
public abstract class AbstractChannel extends DefaultAttributeMap implements Channel {
    //...
    protected abstract class AbstractUnsafe implements Unsafe {
        //...

        @Override
        public final void register(EventLoop eventLoop, final ChannelPromise promise) {
            //...

            AbstractChannel.this.eventLoop = eventLoop;

            if (eventLoop.inEventLoop()) {
                register0(promise);
            } else {
                try {
                    //这个地方调用线程池的execute方法开启一个线程
                    eventLoop.execute(new Runnable() {
                        @Override
                        public void run() {
                            register0(promise);
                        }
                    });
                } catch (Throwable t) {
                    //...
                }
            }
        }

        private void register0(ChannelPromise promise) {
            try {
                //...
                boolean firstRegistration = neverRegistered;
                //真正注册的地方
                doRegister();
                neverRegistered = false;
                registered = true;

                pipeline.invokeHandlerAddedIfNeeded();

                safeSetSuccess(promise);
                pipeline.fireChannelRegistered();

                if (isActive()) {
                    if (firstRegistration) {
                        pipeline.fireChannelActive();
                    } else if (config().isAutoRead()) {
                        beginRead();
                    }
                }
            } catch (Throwable t) {
                //...
            }
        }
             
}
```

```java
public abstract class AbstractNioChannel extends AbstractChannel {
	@Override
    protected void doRegister() throws Exception {
        boolean selected = false;
        
        //死循环，要么注册成功，要么抛出异常
        for (;;) {
            try {
                //获得在构造函数中初始化的nio channel并注册到selector上
                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
                return;
            } catch (CancelledKeyException e) {
                if (!selected) {
                    //假如捕获到cancelled异常，此时这个key可能还存在，因为没有人去调用过select方法，所以这里强制去select一次
                    eventLoop().selectNow();
                    selected = true;
                } else {
                    throw e;
                }
            }
        }
    }
    
    //javaChannel方法返回一个java nio的SelectableChannel
    protected SelectableChannel javaChannel() {
        return ch;
    }
}
```

##### Reactor三部曲之轮询

![wps56B1.tmp](https://img2018.cnblogs.com/blog/1485398/201810/1485398-20181025005700385-1798901391.png)

上面从源码中看到，NioEventLoop继承自一个自定义的单线程线程池，那么这个线程池中的线程在什么时候启动呢？

在上面的AbstractChannel的register中，注册操作中有一步调用execute，对应执行SingleThreadExecutor中的execute方法

```java
            if (eventLoop.inEventLoop()) {
                register0(promise);
            } else {
                try {
                    //这个地方调用线程池的execute方法开启一个线程
                    eventLoop.execute(new Runnable() {
                        @Override
                        public void run() {
                            register0(promise);
                        }
                    });
                } catch (Throwable t) {
                    //...
                }
            }
```

```java
public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
	//...
	@Override
    public void execute(Runnable task) {
        if (task == null) {
            throw new NullPointerException("task");
        }

        boolean inEventLoop = inEventLoop();
        addTask(task);
        if (!inEventLoop) {
            startThread();
            if (isShutdown()) {
                boolean reject = false;
                try {
                    if (removeTask(task)) {
                        reject = true;
                    }
                } catch (UnsupportedOperationException e) {
                }
                if (reject) {
                    reject();
                }
            }
        }

        if (!addTaskWakesUp && wakesUpForTask(task)) {
            wakeup(inEventLoop);
        }
    }
}    
```

上面只是开启一个线程池，具体轮询的逻辑在NioEventLoop#run()中

```java
protected void run(){
        for (;;) {
            try {
                try {
                    switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {
                    case SelectStrategy.CONTINUE:
                        continue;
                    case SelectStrategy.BUSY_WAIT:
                    case SelectStrategy.SELECT:
                        select(wakenUp.getAndSet(false));

                        // 'wakenUp.compareAndSet(false, true)' is always evaluated
                        // before calling 'selector.wakeup()' to reduce the wake-up
                        // overhead. (Selector.wakeup() is an expensive operation.)
                        //
                        // However, there is a race condition in this approach.
                        // The race condition is triggered when 'wakenUp' is set to
                        // true too early.
                        //
                        // 'wakenUp' is set to true too early if:
                        // 1) Selector is waken up between 'wakenUp.set(false)' and
                        //    'selector.select(...)'. (BAD)
                        // 2) Selector is waken up between 'selector.select(...)' and
                        //    'if (wakenUp.get()) { ... }'. (OK)
                        //
                        // In the first case, 'wakenUp' is set to true and the
                        // following 'selector.select(...)' will wake up immediately.
                        // Until 'wakenUp' is set to false again in the next round,
                        // 'wakenUp.compareAndSet(false, true)' will fail, and therefore
                        // any attempt to wake up the Selector will fail, too, causing
                        // the following 'selector.select(...)' call to block
                        // unnecessarily.
                        //
                        // To fix this problem, we wake up the selector again if wakenUp
                        // is true immediately after selector.select(...).
                        // It is inefficient in that it wakes up the selector for both
                        // the first case (BAD - wake-up required) and the second case
                        // (OK - no wake-up required).
   
                        if (wakenUp.get()) {
                            selector.wakeup();
                        }
                    default:
                    }
                } catch (IOException e) {
                    //...
                }

                cancelledKeys = 0;
                needsToSelectAgain = false;
                //这里会根据io比例来设置任务执行的超时时间
                final int ioRatio = this.ioRatio;
                if (ioRatio == 100) {
                    try {
                        processSelectedKeys();
                    } finally {
                        runAllTasks();
                    }
                } else {
                    final long ioStartTime = System.nanoTime();
                    try {
                        processSelectedKeys();
                    } finally {
                        final long ioTime = System.nanoTime() - ioStartTime;
                        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                    }
                }
            } catch (Throwable t) {
                handleLoopException(t);
            }
            try {
                if (isShuttingDown()) {
                    closeAll();
                    if (confirmShutdown()) {
                        return;
                    }
                }
            } catch (Throwable t) {
                handleLoopException(t);
            }
        }
}
```

```java
private void processSelectedKeys() {
        if (selectedKeys != null) {
            processSelectedKeysOptimized();
        } else {
            processSelectedKeysPlain(selector.selectedKeys());
        }
}
    
private void processSelectedKeysOptimized() {
    	//为每个事件调用processSelectedKey来处理
        for (int i = 0; i < selectedKeys.size; ++i) {
            final SelectionKey k = selectedKeys.keys[i];
            selectedKeys.keys[i] = null;

            final Object a = k.attachment();
            //检查是否为AbstractNioChannel的实例
            if (a instanceof AbstractNioChannel) {
                //处理这个key的事件
                processSelectedKey(k, (AbstractNioChannel) a);
            } else {
                @SuppressWarnings("unchecked")
                NioTask<SelectableChannel> task = (NioTask<SelectableChannel>) a;
                processSelectedKey(k, task);
            }

            if (needsToSelectAgain) {
                selectedKeys.reset(i + 1);

                selectAgain();
                i = -1;
            }
        }
}
```

```java
private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
    	//NioUnsafe是AbstractNioChannel的一个内部类，负责用来对底层的channel做处理，例如连接、读、写等
        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
        if (!k.isValid()) {
            //...
        }

        try {
            int readyOps = k.readyOps();
            //连接就绪事件
            if ((readyOps & SelectionKey.OP_CONNECT) != 0) {
                
                int ops = k.interestOps();
                ops &= ~SelectionKey.OP_CONNECT;
                k.interestOps(ops);

                unsafe.finishConnect();
            }

            //写就绪事件
            if ((readyOps & SelectionKey.OP_WRITE) != 0) {
                ch.unsafe().forceFlush();
            }
            
            //读就绪事件
            if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
                unsafe.read();
            }
        } catch (CancelledKeyException ignored) {
            unsafe.close(unsafe.voidPromise());
        }
}
```

##### Reactor三部曲之分派

