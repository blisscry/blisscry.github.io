---

layout:     post
title:      java多线程进阶
subtitle:   java多线程进阶
date:       2019-10-11
author:     skaleto
catalog: true
tags:
    - java，多线程

---

# 



### 并发编程的挑战

#### 上下文切换

在单核处理器中，如果要实现多线程，其实在CPU内部还是串行处理的，CPU通过时间片分配算法来切换每一个任务。在切换前会保存上一个任务的状态，下次切换回这个任务时会加载这个状态。因此线程的一次切换会对应一次上下文的切换，这种切换是会影响执行效率的。



##### 减少上下文切换的方法

- 无锁并发编程，例如将数据的ID按照Hash取模分段，不同县城处理不同的数据
- CAS算法，CAS算法不需要加锁
- 使用最少线程
- 协程，在单线程中使用多个协程来实现多任务调度



#### 避免死锁的几个方法

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
- 使用定时锁，使用tryLock(timeout)
- 数据库锁的加锁和解锁必须在一个数据库连接里



#### 资源限制的挑战

##### 资源限制

在进行并发编程时，程序的执行速度受限于计算机硬件或软件资源

##### 如何解决资源限制的问题

对于硬件资源限制，考虑使用集群来并行执行程序，通过“数据ID%机器数”来得到一个机器编号；

对于软件资源限制，考虑使用资源池将资源进行复用，例如数据库连接池，socket连接复用

- 



### Java并发机制的底层原理

#### Volatile使用优化

在LinkedTransferQueue中（jdk1.7 concurrent包中新增），内部类PaddedAtomicReference（但是我从源码中并没有找到）中将共享变量追加到了64字节。原因是在大多数CPU平台上，高速缓存行是64个字节宽。这就意味着，当一个队列的共享变量大小不足64字节时，例如4个字节时，在多个处理器的情况下，每个处理器都需要4个字节的空间，那么就会存在一个缓存行中存放了多个处理器中的共享变量。在对变量进行修改时，处理器会将一个缓存行锁定，这就意味着其他处理器没有办法访问这个缓存行中自己存放的内容了。假如使用64字节，就可以保证每个处理器都占用一个缓存行。

*不得不说Doug lea太强了*



#### Java对象头

synchronized用的锁是存放在Java对象头中的。

数组类型对象，使用3字宽存储对象头；非数组类型对象，使用2字宽存储对象头，具体结构如下图。

*在32位虚拟机中，1字宽=4字节=32bit

![1571642327984](..\img\multithread\1571642327984.png)

##### Mark Word

存放了对象的hashcode、分代年龄和锁标记位

- 32-bit下，Mark Word为32bit长，可能存在下面四种不同的存储结构

  ![1571642571768](..\img\multithread\1571642571768.png)

- 64-bit下，Mark Word为64bit长，存在下面两种情况

  ![1571642716775](..\img\multithread\1571642716775.png)



#### Java的几种锁

##### 偏向锁

例如ReentrantLock

大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获取，因此为了让同一线程获取锁的代价更低，就引入了偏向锁。

当线程获取锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，当下次这个线程尝试进入和退出锁定的块时，不需要CAS操作来加锁解锁，只需要校验一下记录的线程ID是否和当前一致即可。

###### 撤销偏向锁

偏向锁实际上加锁后就一直没有释放，直到有其他的线程来竞争这个锁，当有其他线程来竞争时，会先暂停偏向锁的线程（前提是当前没有正在执行的字节码，否则暂停肯定会有问题），偏向锁要么重新偏向其他线程，要么被设置为无锁状态或者标记对象不适合用偏向锁。

![1571647325177](..\img\multithread\1571647325177.png)

###### 关闭偏向锁

偏向锁在Java6,7中默认启动，但是是延迟启动，可以用-XX:BiasedLockingStartupDelay=0来关闭延迟；可以用-XX:-UseBiasedLocking=false来关闭偏向锁，并进入轻量级锁



##### 自旋锁

假如某个锁的持有时间比较短，那么假设A线程在竞争锁的时候，该锁被B线程占用着，正常情况下A线程需要阻塞等待锁释放，但由于前提条件锁的持有时间比较短，A线程此时不阻塞，而是进行自旋（例如执行空的for循环），在自旋的过程中不断尝试去获取锁，假如自旋过程中正常获得锁了，那么线程A就正常执行；假如自旋过程中没有获得锁，那么线程A就只能阻塞。

这种自旋方式等待锁是有上面所说的前提的，假如锁的持有时间比较长，或者是计算密集型的线程，那么使用自旋锁是得不偿失的，因为不断自旋会消耗CPU。并且，在单核处理器上，由于不存在真正的多线程，因此多个线程之间必然要阻塞，也是不能使用自旋锁的。

JVM也对自旋锁做了优化，假如线程A在上一次竞争锁的时候成功了，那么下一次竞争的时候自旋的时间相应会变长，反之自旋时间会变短。这种方式叫做自适应自旋锁，是建立在JVM认为每个线程持有锁的时间基本相当的假设上的。



##### 轻量级锁

线程在执行同步块前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，然后线程尝试用CAS将对象头中的MarkWord替换为指向锁记录的指针，成功则当前线程获得锁，失败则其他线程在竞争锁，当前线程自旋来获取锁。

轻量级锁是建立在当前系统中实际上没有锁的竞争存在的假设上，这种锁仅需要在对象头中记录状态，不需要实际向系统申请互斥量。

![1571749798845](..\img\multithread\1571749798845.png)



##### 重量级锁

常用的synchronized，在jdk5之前就是重量级锁，直接向系统申请互斥量，竞争失败的线程直接阻塞；

而在jdk6之后，synchronized内部也加入了偏向锁和轻量级锁的优化。



#### 原子操作

##### CPU术语定义

缓存行（cache line）：缓存的最小操作单位

比较和交换（Compare and Swap，CAS操作）：输入一个旧值一个新值，先比较旧值有没有变化，如果没有变化则改为新值，如果有变化则不改变

内存顺序冲突（Memory order violation）：多个CPU同时修改一个缓存行，引起其中的一个CPU操作无效

##### 处理器实现原子操作

- 总线锁，当一个处理器在使用总线输出信号时，其他处理器的请求会被阻塞，使得每个处理器可以独占共享内存
- 缓存锁，如果内存区域在缓存行上，那么它在锁定期间处理器不在总线上声明lock，只是修改内存地址并保证缓存的一致性

##### JAVA实现原子操作

- 循环CAS操作，例如自旋CAS的实现就是循环进行CAS直到成功为止，例如java并发包中的AtomicBoolean，AtomicInteger等等
  - ABA问题，如果一个值从A变为B又变为A，那么CAS会认为没有发生变化，解决办法就是为每个值加上版本号，例如AtomicStampedReference
  - 循环CAS操作十分消耗CPU
  - CAS只能对一个变量进行原子操作，解决办法就是把多个变量合成一个对象来进行原子操作，例如jdk的AtomicReference可以放入多个变量来进行原子操作
- 使用锁机制来实现，java中除了偏向锁，其他锁在加锁的时候也是使用循环CAS来获取锁，解锁的时候使用循环CAS来释放锁



#### JAVA内存模型

java线程的内存模型在介绍volatile关键字的时候已经介绍过。

![1571813781568](..\img\multithread\1571813781568.png)



#### 指令重排序

程序执行过程中，为了提高性能，编译器和处理器会对指令进行重排序

- 编译器优化的重排序，编译器在不改变单线程语义的前提下重新安排执行顺序

- 指令级并行的重排序，现代处理器采用指令级并行技术使得多条指令可以重叠执行

- 内存系统的重排序，处理器根据缓存和读写缓冲区进行重排序（由于存在缓冲区，实际操作可能读发生在写之前，导致读到的内容并不是写缓存中即将更新的内容）

JMM（java内存模型）要求Java编译器在生成指令序列时，插入特定类型的内存屏障，来禁止特定类型的处理器重排序，内存屏障有如下几种类型：

![1571814699000](..\img\multithread\1571814699000.png)

在java模型中，用happens-before来阐述这些不同重排序下内存的可见性



#### 数据依赖性

如果两个操作同时访问一个变量，并且两个操作中有一个是写操作，那么这两个操作之间是有数据依赖性的，编译器为了保证在单线程场景下，执行效果一致，不会对存在数据依赖性的两个操作进行指令重排序，因为那样很有可能会改变最终结果

```java
//下面三个操作，前两个指令可以互换位置而不会影响最终结果，但是最后一个指令不可以被放到前面
double pi = 3.14;
double r = 1.0;
double area = pi * r * r;

//下面这个操作中，在单线程环境下1,2之间、3，4之间没有数据依赖性，所以有可能发生指令重排；
//当多线程环境下，很容易发现，有可能falg已经被设置为true但a还未更新，这种情形下得到的i是0
class ReorderExample {
	int a = 0;
	boolean flag = false;
	public void writer() {
		a = 1;         // 1
		flag = true;   // 2
	}
    
	Public void reader() {
		if (flag) {    // 3
		int i = a * a; // 4
		}
	}
}
```



#### volatile的内存语义

为了实现volatile的内存语义，JMM会分别限制编译器重排序和处理器重排序，规则如下

![1571822161761](..\img\multithread\1571822161761.png)

从表中我们可以看到几个特点：

- 当第二个操作是volatile写时，不管前面操作是什么，都不能重排序，保证了volatile写一定是最后的操作
- 当第一个操作是volatile读时，不管后面操作是什么，都不能重排序，保证了volatile读一定是最先发生的
- 当第一个操作是volatile写，第二个操作时volatile读时，不能重排序

JMM在指令序列前加入内存屏障来禁止指令重排

- 在每个volatile写操作的前面插入一个StoreStore屏障
- 在每个volatile写操作的后面插入一个StoreLoad屏障
- 在每个volatile读操作的后面插入一个LoadLoad屏障
- 在每个volatile读操作的后面插入一个LoadStore屏障

那么volatile写在插入内存屏障后就变成下面的指令序列

![1571822512969](..\img\multithread\1571822512969.png)





#### 锁的内存语义

以ReentrantLock为例，它的实现依赖于Java同步器框架AbstractQueuedSynchronizer（本文简称之为
AQS）。AQS使用一个整型的volatile变量（命名为state）来维护同步状态，这个变量是实现ReentrantLock内存语义的关键。

```java
//-------------------------公平锁--------------------------
private volatile int state;
/**
 * 加锁
 * ReentrantLock#lock() -> FairSync:lock() -> AbstractQueuedSynchronizer#acquire(int arg) -> ReentrantLock#tryAcquire(int acquires)
 */
protected final boolean tryAcquire(int acquires) {
	final Thread current = Thread.currentThread();
	int c = getState();　　　　// 获取锁的开始，首先读volatile变量state
	if (c == 0) {
		if (isFirst(current) && compareAndSetState(0, acquires)) {
			setExclusiveOwnerThread(current);
			return true;
		}
	} else if (current == getExclusiveOwnerThread()) {
		int nextc = c + acquires;
		if (nextc < 0)　
			throw new Error("Maximum lock count exceeded");
			setState(nextc);
			return true;
		}
	return false;
}


/**
 * 解锁
 * ReentrantLock#unlock() -> AbstractQueuedSynchronizer#release(int arg) -> Sync#tryRelease(int releases)
 */
protected final boolean tryRelease(int releases) {
	int c = getState() - releases;
	if (Thread.currentThread() != getExclusiveOwnerThread())
		throw new IllegalMonitorStateException();
		boolean free = false;
		if (c == 0) {
			free = true;
			setExclusiveOwnerThread(null);
		}
		setState(c);　　　　　// 释放锁的最后，写volatile变量state
		return free;
}


//-------------------------非公平锁---------------------------
/**
 * 加锁
 * ReentrantLock:lock() -> NonfairSync:lock() -> AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)
 */
protected final boolean compareAndSetState(int expect, int update) {
    //这里调用了系统实现的CAS操作，本质上同时具有volatile读和volatile写操作
	return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```

不管是公平锁还是非公平锁，我们都可以看到在加锁时会存在一个volatile读或volatile读写，意味着在它们之后，会存在内存屏障，禁止指令的重排，内存屏障会持续到解锁时的volatile写。

Java线程之间的通信现在有了下面4种方式：

- A线程写volatile变量，随后B线程读这个volatile变量
- A线程写volatile变量，随后B线程用CAS更新这个volatile变量
- A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量（因为CAS同时有volatile读和写的内存语义）
- A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量

Java concurrent包中的多数基础类都会按照下面的模式来实现

- 首先，声明共享变量为volatile
- 然后，使用CAS的原子条件更新来实现线程之间的同步
- 同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信

![1571904423456](..\img\multithread\1571904423456.png)



#### final的内存语义

由于java中final具有不可更改的特性，意味着在final的值初始化（初始化要么在变量定义的时候，要么在类的构造方法中）的过程中，不能发生重排，否则可能出现得到的final值不一致的问题，因此会在final读和写的前后加入内存屏障。但是这个语义在JSR-133上才被加入，保证了在不使用同步(lock或volatile)的情况下，就能保证任意线程能看到正常初始化的final值。



#### happens-before

JMM最核心的概念。

开发者希望内存模型易于理解（强内存模型）；而编译器和处理器希望内存模型对他们的束缚越小越好，以便于他们进行优化（弱内存模型）。JMM就是希望在这里面找到一个平衡。

按照这样的思路，JMM提出了一种happens-before规则，程序员通过这种规则可以理解并进行内存可见性开发。但在内部，JMM对两种情况作了分别处理，对于会改变程序执行结果的重排序，JMM会禁止处理器和编译器进行重排，对于其他不影响执行结果的重排序，JMM不会去做限制。

![1571906803476](..\img\multithread\1571906803476.png)

![1571907488556](..\img\multithread\1571907488556.png)



#### 再看单例模式下的双重检查锁

```java
public class DoubleCheckedLocking {                     // 1
	private static Instance instance;                   // 2
	public static Instance getInstance() {              // 3
		if (instance == null) {                         // 4:第一次检查
			synchronized (DoubleCheckedLocking.class) { // 5:加锁
				if (instance == null)                   // 6:第二次检查
					instance = new Instance();          // 7:问题的根源出在这里
			}                                           // 8
		}                                               // 9
		return instance;                                // 10
	}                                                   // 11
}
```

上面是一个双重检查锁单例的错误示范。

一个对象的创建分为下面三个步骤：

- 分配对象的内存空间
- 初始化对象
- 设置instance指向刚分配的内存地址

上面的三个步骤由于在单线程场景下重排不会影响结果，因此编译器是有可能对它进行重排的，也就意味着有可能instance已经指向了某个内存地址，但还未完成初始化，但在其他线程里已经可以看到这个对象不为null，所以就拿去用了，但是其实对象还没有初始化完成，直接使用就会出现问题。

所以我们有两种思路避免这个问题：

1. 不允许步骤2和3进行指令重排
2. 允许指令重排，但不允许其他线程看到这个重排



对于思路1，我们使用一个volatile来修饰instance，就可以在最后加上一个volatile写屏障，禁止中间的指令重排

对于思路2，我们可以使用静态方法或静态内部类的方式进行实例的初始化，由于JAVA内部对类的初始化由锁来控制同时只能有一个线程进行初始化，变相的也解决了这个问题，但是在这种方式中我们看到，并没有禁止指令的重排，只是对于其他的线程不可见了。



