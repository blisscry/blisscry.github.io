---

layout:     post
title:      java多线程
subtitle:   java多线程
date:       2019-10-11
author:     skaleto
catalog: true
tags:
    - java，多线程

---

# Java多线程



##### 停止线程

1. run方法执行完成后自动退出
2. Thread.run()，不要用
3. Thread.interrupt()，只是将线程中的isInterrupted标志置为true，需要业务侧自行处理

##### interrupted()

检查当前线程的中断状态并且把中断标记置为false（也就是说连续两次interrupted方法的调用，第二次一定是false）

##### isInterrupted()

检查当前线程的中断状态，但不重置中断标记

##### 暂停线程

suspend()用来暂停，resume()用来继续，但是他们存在严重的问题

1. 独占，例如在一个线程中间的某个同步方法执行了suspend，那么任何其他线程都无法进入这个同步方法，因为上一个线程还在占用这个同步方法，并且还没有退出。或者说在一个线程中执行了println方法（println源代码中有一个同步块），也将使得后面的方法没有办法使用这个同步块内的代码。
2. 不同步，很明显，和中断一样，有可能会导致暂停前后的数据不一致

##### Thread.yield()

使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了。

##### 线程的优先级

setPriority(int p)，p为1~10的int型

有三种预定义的优先级，MIN:1，NORM:5，MAX:10

线程的优先级具有继承性，A启动了B的线程，那么B线程的优先级始终和A一致，即使过程中有改变

优先级只影响每个线程得到的CPU资源，不影响执行顺序

##### 守护线程

当进程中不存在非守护线程时，守护线程自动销毁。垃圾回收线程就是一种守护线程。



##### synchronized

是对象锁，也就是说在线程A获得某个对象的某个方法的锁时，线程B不能访问这个方法，同时，B也不能访问这个对象的其他同步方法，但是非同步方法可以访问。

##### synchronized锁重入

当一个线程得到某个对象的对象锁时，再次请求此对象锁时时可以再次得到该对象的锁的。也就是说线程A获得对象的锁之后，在某个同步方法中调用同一个类中的其他同步方法，是永远可以得到锁的。这个现象在继承关系的类中也同样适用，子类获得的锁永远可以重入父类的同步锁。

但是，父类的同步方法如果在子类中被重写为非同步方法，那么调用子类的这个方法时是不具有同步性质的。

##### synchronized代码块

synchronized方法是对整个类的对象加锁，在一些比较耗时的场景下，其实是没必要对整个对象加锁的，所以就有了同步代码块。

同样的，在线程A获得某个同步代码块的锁之后，其他线程也只能访问这个对象中的非同步代码块。

事实上synchronized方法和synchronized(this){代码块}锁的都是当前对象，意味着当前对象的所有具有相同对象监视器的方法和代码都需要同步执行，但假如使用synchronized(非this对象){代码块}来执行，那么这个锁具有不同的对象监视器，可以和锁其他对象的方法异步执行。

##### synchronized锁静态方法或synchronized(A.class)

这两种方式都是直接对Class加锁，意味着会对该Class的所有实例对象生效，并且和非静态方法的锁不是同一个，可以异步调用。

##### String常量池的问题

假如我们在一个String a=“A"上加锁，那么所有请求字符串”A“的线程都会认为是请求同一把锁，也就是说，两个相同的字符串，对应的是同一个常量对象。