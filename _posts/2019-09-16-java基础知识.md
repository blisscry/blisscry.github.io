
Java异常

异常分类

Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception
Error
1.  Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果
出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。
Exception （ RuntimeException、CheckedException ）
2.  Exception 又 有 两 个 分 支 ， 一 个 是 运 行 时 异 常 RuntimeException ， 一 个 是
CheckedException。


Java反射

动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结
构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，
而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。

在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；
并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方
法的功能成为 Java 语言的反射机制。

编译时类型和运行时类型
在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由
声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 

使用 Class 类中的 forName() 静态方法 来获取class对象最安全 / 性能最好

A nnotation（注解）是 Java 提供的一种对元程序中元素关联信息和元数据（metadata）的途径
和方法。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation
对象，然后通过该 Annotation 对象来获取注解中的元数据信息。

@Target 修饰的对象范围
 Annotation可被用于 packages、types（类、
接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数
和本地变量（如循环变量、catch 参数）

@Retention 定义 被保留的时间长短
Retention 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描
述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由：
  SOURCE:在源文件中有效（即源文件保留）
  CLASS:在 class 文件中有效（即 class 保留）
  RUNTIME:在运行时有效（即运行时保留）

@Documented  描述-javadoc

@Inherited  阐述了某个被标注的类型是被继承的
@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一
个使用了@Inherited 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该
class 的子类。


JAVA  内部类

内部类分为静态内部类，
成员内部类（非静态的内部类），局部内部类（定义在方法中的内部类），匿名内部类四种
匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一
个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引
用。


类型擦除 类型擦除
Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛
型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个
过程就称为类型擦除。如在代码中定义的 List<Object>和 List<String>等类型，在编译之后
都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。
类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般
是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换
成具体的类。

序列化对象以字节数组保持 - 静态成员不保存
使用 Java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装
成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对
象序列化不会关注类中的静态变量。

服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串
等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在
客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的
数据安全


将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式
是浅拷贝，第三种是深拷贝。

浅拷贝（Shallow Copy）：①对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。②对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。

浅拷贝的实现方式主要有三种：

一、通过拷贝构造方法实现浅拷贝：

二、通过重写clone()方法进行浅拷贝：

Object类是类结构的根类，其中有一个方法为protected Object clone() throws CloneNotSupportedException，这个方法就是进行的浅拷贝。


深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间。

深拷贝的实现方法主要有两种：

一、通过重写clone方法来实现深拷贝

二、通过对象序列化实现深拷贝

虽然层次调用clone方法可以实现深拷贝，但是显然代码量实在太大。特别对于属性数量比较多、层次比较深的类而言，每个类都要重写clone方法太过繁琐。

将对象序列化为字节序列后，默认会将该对象的整个对象图进行序列化，再通过反序列即可完美地实现深拷贝。
